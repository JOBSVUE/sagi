version: '3.8'
services:
  backend:
    volumes:
      - "./:/app"
      -
        type: bind
        source: ./install_tool_dependencies.sh
        target: /app/install_tool_dependencies.sh
        content: |
          #!/bin/bash
          # Update and upgrade apt settings and apps
          apt update && apt upgrade -y
          xargs apt install -y < /app/requirements_apt.txt
          # Run the project's main requirements.txt
          pip install -r /app/requirements.txt
          for tool in /app/superagi/tools/* /app/superagi/tools/external_tools/* /app/superagi/tools/marketplace_tools/* ; do
          # Loop through the tools directories and install their apt_requirements.txt if they exist
            if [ -d "$tool" ] && [ -f "$tool/requirements_apt.txt" ]; then
              echo "Installing apt requirements for tool: $(basename "$tool")"
              xargs apt install -y < "$tool/requirements_apt.txt"
            fi
          # Loop through the tools directories and install their requirements.txt if they exist
            if [ -d "$tool" ] && [ -f "$tool/requirements.txt" ]; then
              echo "Installing requirements for tool: $(basename "$tool")"
              pip install -r "$tool/requirements.txt"
            fi
          done
      -
        type: bind
        source: ./wait-for-it.sh
        target: /app/wait-for-it.sh
        content: |
          #!/usr/bin/env bash
          WAITFORIT_cmdname=${0##*/}
          echoerr() { if [[ $WAITFORIT_QUIET -ne 1 ]]; then echo "$@" 1>&2; fi }
          usage()
          {
              cat << USAGE >&2
          Usage:
              $WAITFORIT_cmdname host:port [-s] [-t timeout] [-- command args]
              -h HOST | --host=HOST       Host or IP under test
              -p PORT | --port=PORT       TCP port under test
                                          Alternatively, you specify the host and port as host:port
              -s | --strict               Only execute subcommand if the test succeeds
              -q | --quiet                Don't output any status messages
              -t TIMEOUT | --timeout=TIMEOUT
                                          Timeout in seconds, zero for no timeout
              -- COMMAND ARGS             Execute command with args after the test finishes
          USAGE
              exit 1
          }
          
          wait_for()
          {
              if [[ $WAITFORIT_TIMEOUT -gt 0 ]]; then
                  echoerr "$WAITFORIT_cmdname: waiting $WAITFORIT_TIMEOUT seconds for $WAITFORIT_HOST:$WAITFORIT_PORT"
              else
                  echoerr "$WAITFORIT_cmdname: waiting for $WAITFORIT_HOST:$WAITFORIT_PORT without a timeout"
              fi
              WAITFORIT_start_ts=$(date +%s)
              while :
              do
                  if [[ $WAITFORIT_ISBUSY -eq 1 ]]; then
                      nc -z $WAITFORIT_HOST $WAITFORIT_PORT
                      WAITFORIT_result=$?
                  else
                      (echo -n > /dev/tcp/$WAITFORIT_HOST/$WAITFORIT_PORT) >/dev/null 2>&1
                      WAITFORIT_result=$?
                  fi
                  if [[ $WAITFORIT_result -eq 0 ]]; then
                      WAITFORIT_end_ts=$(date +%s)
                      echoerr "$WAITFORIT_cmdname: $WAITFORIT_HOST:$WAITFORIT_PORT is available after $((WAITFORIT_end_ts - WAITFORIT_start_ts)) seconds"
                      break
                  fi
                  sleep 1
              done
              return $WAITFORIT_result
          }
          
          wait_for_wrapper()
          {
              # In order to support SIGINT during timeout: http://unix.stackexchange.com/a/57692
              if [[ $WAITFORIT_QUIET -eq 1 ]]; then
                  timeout $WAITFORIT_BUSYTIMEFLAG $WAITFORIT_TIMEOUT $0 --quiet --child --host=$WAITFORIT_HOST --port=$WAITFORIT_PORT --timeout=$WAITFORIT_TIMEOUT &
              else
                  timeout $WAITFORIT_BUSYTIMEFLAG $WAITFORIT_TIMEOUT $0 --child --host=$WAITFORIT_HOST --port=$WAITFORIT_PORT --timeout=$WAITFORIT_TIMEOUT &
              fi
              WAITFORIT_PID=$!
              trap "kill -INT -$WAITFORIT_PID" INT
              wait $WAITFORIT_PID
              WAITFORIT_RESULT=$?
              if [[ $WAITFORIT_RESULT -ne 0 ]]; then
                  echoerr "$WAITFORIT_cmdname: timeout occurred after waiting $WAITFORIT_TIMEOUT seconds for $WAITFORIT_HOST:$WAITFORIT_PORT"
              fi
              return $WAITFORIT_RESULT
          }
          while [[ $# -gt 0 ]]
          do
              case "$1" in
                  *:* )
                  WAITFORIT_hostport=(${1//:/ })
                  WAITFORIT_HOST=${WAITFORIT_hostport[0]}
                  WAITFORIT_PORT=${WAITFORIT_hostport[1]}
                  shift 1
                  ;;
                  --child)
                  WAITFORIT_CHILD=1
                  shift 1
                  ;;
                  -q | --quiet)
                  WAITFORIT_QUIET=1
                  shift 1
                  ;;
                  -s | --strict)
                  WAITFORIT_STRICT=1
                  shift 1
                  ;;
                  -h)
                  WAITFORIT_HOST="$2"
                  if [[ $WAITFORIT_HOST == "" ]]; then break; fi
                  shift 2
                  ;;
                  --host=*)
                  WAITFORIT_HOST="${1#*=}"
                  shift 1
                  ;;
                  -p)
                  WAITFORIT_PORT="$2"
                  if [[ $WAITFORIT_PORT == "" ]]; then break; fi
                  shift 2
                  ;;
                  --port=*)
                  WAITFORIT_PORT="${1#*=}"
                  shift 1
                  ;;
                  -t)
                  WAITFORIT_TIMEOUT="$2"
                  if [[ $WAITFORIT_TIMEOUT == "" ]]; then break; fi
                  shift 2
                  ;;
                  --timeout=*)
                  WAITFORIT_TIMEOUT="${1#*=}"
                  shift 1
                  ;;
                  --)
                  shift
                  WAITFORIT_CLI=("$@")
                  break
                  ;;
                  --help)
                  usage
                  ;;
                  *)
                  echoerr "Unknown argument: $1"
                  usage
                  ;;
              esac
          done
          
          if [[ "$WAITFORIT_HOST" == "" || "$WAITFORIT_PORT" == "" ]]; then
              echoerr "Error: you need to provide a host and port to test."
              usage
          fi
          
          WAITFORIT_TIMEOUT=${WAITFORIT_TIMEOUT:-15}
          WAITFORIT_STRICT=${WAITFORIT_STRICT:-0}
          WAITFORIT_CHILD=${WAITFORIT_CHILD:-0}
          WAITFORIT_QUIET=${WAITFORIT_QUIET:-0}
          WAITFORIT_TIMEOUT_PATH=$(type -p timeout)
          WAITFORIT_TIMEOUT_PATH=$(realpath $WAITFORIT_TIMEOUT_PATH 2>/dev/null || readlink -f $WAITFORIT_TIMEOUT_PATH)
          WAITFORIT_BUSYTIMEFLAG=""
          if [[ $WAITFORIT_TIMEOUT_PATH =~ "busybox" ]]; then
              WAITFORIT_ISBUSY=1
              # Check if busybox timeout uses -t flag
              # (recent Alpine versions don't support -t anymore)
              if timeout &>/dev/stdout | grep -q -e '-t '; then
                  WAITFORIT_BUSYTIMEFLAG="-t"
              fi
          else
              WAITFORIT_ISBUSY=0
          fi
          
          if [[ $WAITFORIT_CHILD -gt 0 ]]; then
              wait_for
              WAITFORIT_RESULT=$?
              exit $WAITFORIT_RESULT
          else
              if [[ $WAITFORIT_TIMEOUT -gt 0 ]]; then
                  wait_for_wrapper
                  WAITFORIT_RESULT=$?
              else
                  wait_for
                  WAITFORIT_RESULT=$?
              fi
          fi
          
          if [[ $WAITFORIT_CLI != "" ]]; then
              if [[ $WAITFORIT_RESULT -ne 0 && $WAITFORIT_STRICT -eq 1 ]]; then
                  echoerr "$WAITFORIT_cmdname: strict mode, refusing to execute subprocess"
                  exit $WAITFORIT_RESULT
              fi
              exec "${WAITFORIT_CLI[@]}"
          else
              exit $WAITFORIT_RESULT
          fi
        
    build: .
    depends_on:
      - super__redis
    environment:
      DB_HOST: "${DB_HOST}"
#      - super__postgres
#    networks:
#      - super_network
    command: ["/app/wait-for-it.sh", "${DB_HOST}:5552","-t","60","--","/app/entrypoint.sh"]
  celery:
    volumes:
      - "./:/app"
      - "${EXTERNAL_RESOURCE_DIR:-./workspace}:/app/ext"
      - 
        type: bind
        source: ./entrypoint.sh
        target: /usr/local/bin/entrypoint.sh
        content: |
          #!/bin/bash
          # Downloads the tools from marketplace and external tool repositories
          python superagi/tool_manager.py
          # Install dependencies
          ./install_tool_dependencies.sh
          # Run Alembic migrations
          alembic upgrade head
          # Start the app
          exec uvicorn main:app --host 0.0.0.0 --port 8001 --reload
      - 
        type: bind
        source: ./entrypoint_celery.sh
        target: /usr/local/bin/entrypoint_celery.sh
        content: |
          #!/bin/bash
          # Downloads the tools
          python superagi/tool_manager.py
          # Install dependencies
          ./install_tool_dependencies.sh
          exec celery -A superagi.worker worker --beat --loglevel=info
    build: .
    depends_on:
      - super__redis
#      - super__postgres
#    networks:
#      - super_network
    command: ["/app/entrypoint_celery.sh"]
  gui:
    build:
      context: ./gui
      args:
        NEXT_PUBLIC_API_BASE_URL: "/api"
#    networks:
#      - super_network
#    volumes:
#      - ./gui:/app
#      - /app/node_modules/
#      - /app/.next/
  super__redis:
    image: "redis/redis-stack-server:latest"
#    networks:
#      - super_network
#    uncomment to expose redis port to host
#    ports:
#      - "6379:6379"
    volumes:
      - redis_data:/data

#  super__postgres:
#    image: "docker.io/library/postgres:15"
#    environment:
#      - POSTGRES_USER=superagi
#      - POSTGRES_PASSWORD=password
#      - POSTGRES_DB=super_agi_main
#    volumes:
#      - superagi_postgres_data:/var/lib/postgresql/data/
#    networks:
#      - super_network
#    uncomment to expose postgres port to host
#    ports:
#      - "5432:5432"

  proxy:
    image: nginx:stable-alpine
    ports:
      - "3060:80"
    networks:
      - super_network
    depends_on:
      - backend
      - gui
    volumes:
      #- ./nginx/default.conf:/etc/nginx/conf.d/default.conf
      - 
        type: bind
        source: ./nginx/default.conf
        target: /etc/nginx/conf.d/default.conf
        content: |
          server {
            listen 80;
            location / {
              proxy_pass http://gui:3000;
              proxy_set_header Host $host;
              proxy_set_header X-Real-IP $remote_addr;
              proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            }
            location /api {
              proxy_pass http://backend:8001;
              client_max_body_size 50M;
              proxy_set_header Host $host;
              proxy_set_header X-Real-IP $remote_addr;
              proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
              rewrite ^/api/(.*) /$1 break;
            }
            location /_next/webpack-hmr {
              proxy_pass http://gui:3000;
              proxy_http_version 1.1;
              proxy_set_header Upgrade $http_upgrade;
              proxy_set_header Connection "upgrade";
              proxy_set_header Host $host;
              proxy_cache_bypass $http_upgrade;
            }
          }

networks:
  super_network:
    driver: bridge
    
volumes:
#  superagi_postgres_data:
  redis_data:
